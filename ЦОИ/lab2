import matplotlib.pyplot as plt
import cv2 as cv
import numpy as np
from utility import util

# Изменим стандартный размер графиков matplotlib
plt.rcParams["figure.figsize"] = [6, 4]
image1 = cv.imread(r'lenna_bad.png')
image2 = cv.imread(r'winter_cat.png')
rgb_image1 = cv.cvtColor(image1, cv.COLOR_BGR2RGB)
rgb_image2 = cv.cvtColor(image2, cv.COLOR_BGR2RGB)
gray_image1 = cv.cvtColor(image1, cv.COLOR_BGR2GRAY)
gray_image2 = cv.cvtColor(image2, cv.COLOR_BGR2GRAY)

channels = [0]
histSize = [256]
range = [0, 256]

hist1 = cv.calcHist([gray_image1], channels, None, histSize, range)
hist2 = cv.calcHist([gray_image2], channels, None, histSize, range)

gs = plt.GridSpec(2, 2)
plt.figure(figsize=(10, 8))
plt.subplot(gs[0])
plt.imshow(gray_image1, cmap='gray')
plt.subplot(gs[1])
plt.imshow(gray_image2, cmap='gray')
plt.subplot(gs[2])
plt.hist(gray_image1.reshape(-1), 256, range)
plt.subplot(gs[3])
plt.hist(gray_image2.reshape(-1), 256, range)
plt.show()
# Другие способы визуализации гистограмм:
# 1. С использованием Matplotlib
plt.hist(gray_image1.reshape(-1), 256, range)
plt.show()
# 2. Визуализация гистограммы по каналам
histSize = [256]
range = [0, 256]
def plot_rgb_hist(image, histSize, range):
    histSize = [256]
    range = [0, 256]
    for i, col in enumerate(['b', 'g', 'r']):
        hist = cv.calcHist([image], [i], None, histSize, range)
        plt.plot(hist, color=col)
        plt.xlim(range)

plot_rgb_hist(image1, histSize, range)
plt.show()
#2.1.2 Яркостные (гистограммные) преобразования
"""Гистограммная обработка изображения при помощи таблицы отображения яркости осуществляется следующим образом:
{\rm Im}[i,j] = {\rm LUT[Im}[i,j]],
где Im[i,j] -  пиксел изображения с координатами i,j, 
а LUT -  целочисленный массив размера 256 элементов для 8-битного изображения или длиной 65 536 элементов для 16-битного изображения.
При этом LUT может задаваться:
- произвольной таблицей отображения, формируемой пользователем непосредственно;
- некоторой математической функцией, выбранной из заданного набора функций;
- адаптивно по гистограмме данного анализируемого изображения.
"""
# 2.1.2.1 Инверсия
""" Простейшим примером гистограммной обработки изображений является *инвертирование яркости*, определяемое зависимостью вида
{\rm LUT}[i] = 255 - i.
В результате инвертирования изображения получается его *негатив*. При этом темные области становятся светлыми, и наоборот.
"""
lut = lambda i: 255 - i
invert_image = lut(gray_image1)
plt.imshow(invert_image, cmap='gray')
# 2.1.2.2 Гамма-коррекция
""" Гамма-коррекция --  степенной закон вида
{\rm LUT}[i] = r(i)^{\gamma },
где r -  коэффициент контраста, а gamma -  степень преобразования.
Такие преобразования известны в области аналогового телевидения как процедура гамма-коррекции.
"""
gamma = 1.05
lut = lambda i: i ** gamma
result_image = lut(gray_image1)

gs = plt.GridSpec(2, 2)
plt.figure(figsize=(10, 8))
plt.subplot(gs[0])
plt.imshow(gray_image1, cmap='gray')
plt.subplot(gs[1])
plt.imshow(result_image, cmap='gray')
plt.subplot(gs[2])
plt.hist(gray_image1.reshape(-1), 256, range)
plt.subplot(gs[3])
plt.hist(result_image.reshape(-1), 256, range)
plt.show()

# 2.1.2.3 Адаптивная коррекция
# 2.1.2.3.1 Яркостная нормализация
""" Описывается следующей математической зависимостью:
{\rm LUT}[i] = 255 \cdot  \frac {i - {I_{\min}}} {I_{\max} - I_{\min}}.
I_{\min} = \min\limits_{x,y} \textrm{Im} [x,y]$, $I_{\max} = \max\limits_{x, y} \textrm{Im} [x,y].
Значения I_{\min}$ и $I_{\max} определяются как минимальный и максимальный номера ненулевых ячеек гистограммы Hist(Im).
Данное преобразование равномерно "растягивает" диапазон яркостей
[I_{\min}, I_{\max}], присутствующих на исходном изображении Im,на максимально возможный диапазон [0, 255]. 
Это способствует максимально возможному улучшению контраста изображения без потери каких-либо различийэлементов яркости исходного изображения.
"""
lut = lambda i: 255 * ((i - np.min(i)) / (np.max(i) - np.min(i)))
result_image = lut(gray_image1)

gs = plt.GridSpec(2, 2)
plt.figure(figsize=(10, 8))
plt.subplot(gs[0])
plt.imshow(gray_image1, cmap='gray')
plt.subplot(gs[1])
plt.imshow(result_image, cmap='gray')
plt.subplot(gs[2])
plt.hist(gray_image1.reshape(-1), 256, range)
plt.subplot(gs[3])
plt.hist(result_image.reshape(-1), 256, range)
plt.show()

# 2.1.2.3.2 Эквализация изображения
""" Другой популярной процедурой адаптивной гистограммной обработки изображения является эквализация изображения.
Математическая форма данного преобразования имеет вид:
LUT[i] = 255*{i - {I_{\min}}} {I_{\max} - I_{\min}}.
LUT[i] = 255*{\sum\limits_{j=1}^i \textrm{Hist}[j]}{\sum\limits_{j=1}^{255} \textrm{Hist}[j]},
В тех случаях, когда в диапазоне [Imin,Imax] более или менее равномерно присутствуют все градации,
визуальный эффект от эквализации трудно отличить от эффекта нормализации.
Визуально это выглядит как "проявление" большего количества ранее не заметных на изображении деталей и контуров.
**Задание: реализуйте данный вид эквализации самостоятельно**
"""
lut = lambda i: 255 * ((i - np.min(i)) / (np.max(i) - np.min(i)))
result_image = lut(gray_image1)
